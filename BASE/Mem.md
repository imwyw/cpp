<!-- TOC -->

- [内存管理](#内存管理)
    - [内存管理详解](#内存管理详解)
        - [分配方式](#分配方式)
        - [区分栈和堆](#区分栈和堆)
        - [栈和堆区别](#栈和堆区别)
    - [指针与数组](#指针与数组)
        - [内容修改](#内容修改)

<!-- /TOC -->

<a id="markdown-内存管理" name="内存管理"></a>
# 内存管理
C++内存管理是C++学习中的重难点，正是因为内存的高度自由化掌控，才有如此高的性能，犹如一把锋利的双刃剑。

高手的可以体会到高性能和高度自由化，而新手则会感慨内存的难以控制和难以预防的泄漏。

<a id="markdown-内存管理详解" name="内存管理详解"></a>
## 内存管理详解

<a id="markdown-分配方式" name="分配方式"></a>
### 分配方式
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

- 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

- 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

- 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

- 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

- 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

<a id="markdown-区分栈和堆" name="区分栈和堆"></a>
### 区分栈和堆

简单的一个数组指针声明，既有栈空间也有堆空间的使用：
```cpp
void f() {
	int *p = new int[5]{};
}
```
针对上面的代码：
1. 使用new运算符，即在堆空间进行了内存的申请
2. 申请空间->构造，返回该块区域的首地址
3. 声明了指针p，保存在栈空间，接收堆空间返回的首地址值

上面代码中方法执行完后，申请的堆空间并不会自动释放，需要我们程序员进行人工释放，

由于p所指向的是一块数组空间，应该如下方式进行内存空间的释放：
```cpp
delete[] p;//该步仅仅是将堆空间申请的内存进行释放，并未修改p指针的指向，delete后还需要对p赋空指针。
p = nullptr;
```

<a id="markdown-栈和堆区别" name="栈和堆区别"></a>
### 栈和堆区别

主要区别 | 栈Stack | 堆Leap
-----|--------|------
管理方式 | 编译器自动管理 | 申请和释放都是编码人员控制，容易长生内存泄漏(memory leak)
空间大小 | 跟编译器有关，VS中默认是1M | 从系统内存，对于32位系统最大可为4G，基本上是没有限制的
产生碎片 | 因为栈的特点，FILO/LIFO，不会有碎片的产生 | 频繁的new/delete造成内存空间的不连续，增加了碎片化
生长方向 | 向着内存地址减小的方向增长 | 向着内存地址增加的方向
分配方式 | 也有静态和动态，但都是编译器进行释放 | 动态分配
分配效率 | 底层寄存器的支持，入栈出栈效率很高 | C++库函数支持，寻找空间，归还空间，返回地址等等一系列操作，效率比栈低

总的来说，栈的优点是快速高效，并且不需要人工干预进行释放。

相比较于堆来说的话并没有那么灵活，由开发人员进行控制，并且针对"大"对象的操控使用堆要更加合适。

<a id="markdown-指针与数组" name="指针与数组"></a>
## 指针与数组
C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。

数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。

指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

<a id="markdown-内容修改" name="内容修改"></a>
### 内容修改


引用参考：

[C++内存管理](http://www.cnblogs.com/lancidie/archive/2011/08/05/2128318.html)
[栈增长方向与大端/小端问题](http://www.cnblogs.com/xkfz007/archive/2012/06/22/2558935.html)

> https://blog.csdn.net/hihozoo/article/details/51441521
> http://www.cnblogs.com/dubingsky/archive/0001/01/01/1509831.html